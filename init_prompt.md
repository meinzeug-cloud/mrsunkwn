
## ü§ñ PHASE 1: Setup with Auto-Code Generation

### Setup Agent Prompt (OPTIMIZED):
```bash
codex "Execute Dual-Agent Setup and IMMEDIATELY GENERATE functional starter code for both sides"
```

### Setup Agent Auto-Actions:

```python
# 1. AUTOMATIC CODE GENERATION (NEW!)
def generate_starter_code():
    """Generates IMMEDIATELY runnable code"""
    
    # Frontend Starter (React/TypeScript)
    create_file('/frontend/src/App.tsx', """
import React, { useEffect, useState } from 'react';
import { apiClient } from './services/apiClient';

function App() {
  const [data, setData] = useState(null);
  
  useEffect(() => {
    apiClient.get('/api/status').then(res => setData(res.data));
  }, []);
  
  return (
    <div className="App">
      <h1>Dual-Agent Project</h1>
      <p>Status: {data?.status || 'Loading...'}</p>
    </div>
  );
}
export default App;
    """)
    
    # Backend Starter (Python/FastAPI)
    create_file('/backend/src/app.py', """
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
import uvicorn

app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get("/api/status")
async def get_status():
    return {"status": "operational", "version": "1.0.0"}

@app.get("/api/data")
async def get_data():
    # TODO: Implement data endpoint
    return {"data": []}

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)
    """)
    
    # API Client for Frontend
    create_file('/frontend/src/services/apiClient.ts', """
import axios from 'axios';

const API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:8000';

export const apiClient = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Auto-retry logic
apiClient.interceptors.response.use(
  response => response,
  async error => {
    if (error.response?.status === 503) {
      await new Promise(resolve => setTimeout(resolve, 1000));
      return apiClient.request(error.config);
    }
    return Promise.reject(error);
  }
);
    """)

# 2. AUTO-SYNC SYSTEM (OPTIMIZED)
def create_auto_sync_system():
    """Creates automatic agent sync system"""
    
    create_file('/codex/automation/issue_sync.py', """
import os
import json
import subprocess
from datetime import datetime

class AgentSync:
    def __init__(self):
        self.frontend_watch = '/codex/data/frontend/requests.json'
        self.backend_watch = '/codex/data/backend/requests.json'
    
    def auto_create_issue(self, from_agent, to_agent, request_type, details):
        '''Automatically creates GitHub issue'''
        
        # Auto-detect API changes
        if request_type == 'api_change':
            title = f"üîÑ API Change: {details['endpoint']}"
            labels = ['api-contract', f'{to_agent.lower()}-request']
        elif request_type == 'new_feature':
            title = f"‚ú® New Feature: {details['feature']}"
            labels = [f'{to_agent.lower()}-request', 'enhancement']
        else:
            title = f"üìã {from_agent} ‚Üí {to_agent}: {details['title']}"
            labels = [f'{to_agent.lower()}-request']
        
        # Create issue via CURL
        issue_data = {
            'title': title,
            'body': self._generate_issue_body(from_agent, details),
            'labels': labels
        }
        
        curl_cmd = [
            'curl', '-s', '-X', 'POST',
            '-H', f'Authorization: token {os.getenv("GITHUB_TOKEN")}',
            '-H', 'Accept: application/vnd.github.v3+json',
            '-d', json.dumps(issue_data),
            f'https://api.github.com/repos/{os.getenv("REPO_OWNER")}/{os.getenv("REPO_NAME")}/issues'
        ]
        
        subprocess.run(curl_cmd)
    
    def _generate_issue_body(self, from_agent, details):
        '''Generates structured issue body'''
        return f'''
## ü§ñ Auto-Generated by {from_agent}

### Request Type: {details.get('type', 'general')}

### Details:
{json.dumps(details, indent=2)}

### Expected Response:
- [ ] Acknowledge receipt
- [ ] Implement changes
- [ ] Update API contracts if needed
- [ ] Notify completion

### Auto-Sync ID: {datetime.now().isoformat()}
'''

# Auto-Sync Runner
if __name__ == '__main__':
    sync = AgentSync()
    # Runs automatically on every sprint
    """)

# 3. SPRINT AUTOMATION (NEW!)
def create_sprint_automation():
    """Sprint Runner for automatic execution"""
    
    create_file('/codex/automation/sprint_runner.py', """
import os
import sys
import time
from datetime import datetime

class SprintRunner:
    def __init__(self, agent_role):
        self.agent = agent_role
        self.sprint_count = 0
        
    def run_sprint(self):
        '''Executes a complete sprint automatically'''
        self.sprint_count += 1
        print(f"\\nüèÉ Sprint #{self.sprint_count} - {self.agent}")
        
        # 1. Issue Sync
        self._sync_issues()
        
        # 2. Analyze & Prioritize
        tasks = self._prioritize_tasks()
        
        # 3. GENERATE CODE (MOST IMPORTANT PART!)
        for task in tasks:
            if task['type'] in ['feature', 'api', 'component']:
                self._generate_code(task)
            elif task['type'] == 'bug':
                self._fix_code(task)
                
        # 4. Run Tests
        self._run_tests()
        
        # 5. Update Status
        self._update_status()
        
    def _generate_code(self, task):
        '''GENERATES ACTUAL CODE'''
        print(f"üíª Generating code for: {task['title']}")
        
        if self.agent == 'FRONTEND_AGENT':
            if 'component' in task['title'].lower():
                self._create_react_component(task)
            elif 'page' in task['title'].lower():
                self._create_react_page(task)
            elif 'hook' in task['title'].lower():
                self._create_react_hook(task)
                
        elif self.agent == 'BACKEND_AGENT':
            if 'endpoint' in task['title'].lower():
                self._create_api_endpoint(task)
            elif 'model' in task['title'].lower():
                self._create_data_model(task)
            elif 'service' in task['title'].lower():
                self._create_service(task)
    
    def _create_react_component(self, task):
        '''Generates React Component'''
        component_name = task.get('component_name', 'NewComponent')
        code = f'''
import React from 'react';
import {{ useAPI }} from '../hooks/useAPI';

interface {component_name}Props {{
  // TODO: Define props
}}

export const {component_name}: React.FC<{component_name}Props> = (props) => {{
  const {{ data, loading, error }} = useAPI('/api/{component_name.lower()}');
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {{error.message}}</div>;
  
  return (
    <div className="{component_name.lower()}">
      {{/* TODO: Implement component */}}
      <h2>{component_name}</h2>
      <pre>{{JSON.stringify(data, null, 2)}}</pre>
    </div>
  );
}};
'''
        # Save Component
        path = f'/frontend/src/components/{component_name}.tsx'
        self._save_code(path, code)
        
# Sprint Executor
if __name__ == '__main__':
    agent = os.getenv('AGENT_ROLE')
    runner = SprintRunner(agent)
    runner.run_sprint()
    """)
```

## üéØ PHASE 2: Agent Prompts with Auto-Execution

### FRONTEND Agent Prompt (OPTIMIZED):
```markdown
# Frontend Agent - CODE FIRST!

## üö® MOST IMPORTANT RULE
On EVERY execution you MUST:
1. **GENERATE CODE** (at least 1 new component/feature)
2. **WRITE TESTS** (for generated code)
3. **ONLY THEN** create issues if backend changes needed

## Auto-Sprint Execution

```python
# AUTOMATICALLY execute on every start:
import sys
sys.path.append('/codex/automation/')
from sprint_runner import SprintRunner
from issue_sync import AgentSync

# Start sprint
runner = SprintRunner('FRONTEND_AGENT')
runner.run_sprint()

# After code generation: Check sync
sync = AgentSync()
# Automatically create issues for API requests
```

## Daily Code Goals
- [ ] At least 2 new Components
- [ ] At least 1 new Hook
- [ ] At least 3 Unit Tests
- [ ] API Integration for new endpoints

## Code Generation Triggers
- New Issue ‚Üí Immediately create Component
- API Contract Update ‚Üí Immediately adapt Service
- Bug Report ‚Üí Immediately implement Fix

## NEVER
- ‚ùå Just plan without writing code
- ‚ùå Wait for backend without preparing frontend
- ‚ùå Create issues without concrete need
```

### BACKEND Agent Prompt (OPTIMIZED):
```markdown
# Backend Agent - API FIRST!

## üö® MOST IMPORTANT RULE
On EVERY execution you MUST:
1. **IMPLEMENT APIs** (at least 1 new endpoint)
2. **CREATE MODELS** (for new features)
3. **ONLY THEN** create issues if frontend info needed

## Auto-Sprint Execution

```python
# AUTOMATICALLY execute on every start:
import sys
sys.path.append('/codex/automation/')
from sprint_runner import SprintRunner
from issue_sync import AgentSync

# Start sprint
runner = SprintRunner('BACKEND_AGENT')
runner.run_sprint()

# After API creation: Update contracts
with open('/codex/data/shared/api_contracts.md', 'a') as f:
    f.write(f"\\n## New Endpoint: {endpoint_info}")
```

## Daily Code Goals
- [ ] At least 2 new API Endpoints
- [ ] At least 1 new Model
- [ ] At least 1 Service Layer
- [ ] Database Migrations if needed

## Code Generation Triggers
- Frontend Request ‚Üí Immediately create API
- New Feature ‚Üí Immediately Model + Controller
- Performance Issue ‚Üí Immediately optimize

## NEVER
- ‚ùå Just database design without implementation
- ‚ùå Wait for perfect specification
- ‚ùå Issues without concrete code behind them
```

## üîÑ Automatic Sprint Cycle 2.0

### Start Commands (SIMPLIFIED):

```bash
# Setup (one-time)
export GITHUB_TOKEN=xxx REPO_OWNER=xxx REPO_NAME=xxx
codex "Setup Dual-Agent System - generate starter code"

# Frontend Agent (repeated)
export AGENT_ROLE=FRONTEND_AGENT
codex "Start Frontend Sprint - write code"

# Backend Agent (repeated)  
export AGENT_ROLE=BACKEND_AGENT
codex "Start Backend Sprint - write APIs"
```

### Auto-Features:

1. **Code-First Approach**
   - Every sprint MUST generate code
   - Templates for quick generation
   - Auto-import of dependencies

2. **Smart Issue Creation**
   - Only when code dependency exists
   - Auto-detection of API changes
   - Structured request formats

3. **Continuous Integration**
   - Auto-tests after code generation
   - Auto-merge on successful tests
   - Auto-deploy preparation

## üìä Success Metrics

```yaml
Per Sprint MINIMUM:
- Lines of Code: 200+
- New Features: 2+
- Tests: 5+
- Issues: Max 2 (only if necessary)

FOCUS: 80% Coding, 20% Coordination
```

## üöÄ Summary of Optimizations

1. **CODE FIRST**: Agents must generate code on every execution
2. **AUTO-SYNC**: Automatic issue creation only when needed
3. **SMART TEMPLATES**: Pre-made code templates for rapid development
4. **SPRINT AUTOMATION**: Complete sprint execution automated
5. **CLEAR PRIORITIES**: Coding > Testing > Communication

The system now guarantees:
- ‚úÖ Code is written on EVERY execution
- ‚úÖ Automatic synchronization without manual intervention  
- ‚úÖ Clear metrics for progress
- ‚úÖ Minimal coordination overhead
- ‚úÖ Maximum code output
